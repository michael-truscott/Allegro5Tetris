#include "Piece.h"
#include "global.h"
#include <allegro5/allegro_primitives.h>

//-----------------------------------------------------------------------------
// Piece definitions:
// heeeeeeere we go
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// I
//-----------------------------------------------------------------------------
int I[4][4][4] =
{
	{
		{ 0, 0, 1, 0 },
		{ 0, 0, 1, 0 },
		{ 0, 0, 1, 0 },
		{ 0, 0, 1, 0 }
	},
	{
		{ 0, 0, 0, 0 },
		{ 1, 1, 1, 1 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 1, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 1, 0, 0 }
	},
	{
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 },
		{ 1, 1, 1, 1 },
		{ 0, 0, 0, 0 }
	}
};

//-----------------------------------------------------------------------------
// S
//-----------------------------------------------------------------------------
int S[4][4][4] =
{
	{
		{ 0, 1, 1, 0 },
		{ 1, 1, 0, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 1, 0, 0, 0 },
		{ 1, 1, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 1, 1, 0 },
		{ 1, 1, 0, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 1, 0, 0, 0 },
		{ 1, 1, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 0, 0, 0 }
	}
};

//-----------------------------------------------------------------------------
// Z
//-----------------------------------------------------------------------------
int Z[4][4][4] =
{
	{
		{ 1, 1, 0, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 1, 0, 0 },
		{ 1, 1, 0, 0 },
		{ 1, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 1, 1, 0, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 1, 0, 0 },
		{ 1, 1, 0, 0 },
		{ 1, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	}
};

//-----------------------------------------------------------------------------
// J
//-----------------------------------------------------------------------------
int J[4][4][4] =
{
	{
		{ 1, 0, 0, 0 },
		{ 1, 1, 1, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 1, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 1, 1, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 1, 1, 1, 0 },
		{ 0, 0, 1, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 1, 1, 0, 0 },
		{ 1, 0, 0, 0 },
		{ 1, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	}
};

//-----------------------------------------------------------------------------
// L
//-----------------------------------------------------------------------------
int L[4][4][4] =
{
	{
		{ 0, 0, 1, 0 },
		{ 1, 1, 1, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 1, 1, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 0, 0, 0 },
		{ 1, 1, 1, 0 },
		{ 1, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 1, 0, 0, 0 },
		{ 1, 0, 0, 0 },
		{ 1, 1, 0, 0 },
		{ 0, 0, 0, 0 }
	}
};

//-----------------------------------------------------------------------------
// O
//-----------------------------------------------------------------------------
int O[4][4][4] =
{
	{
		{ 0, 0, 0, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 0, 0, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 0, 0, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 0, 0, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 0, 0, 0 }
	}
};

//-----------------------------------------------------------------------------
// T
//-----------------------------------------------------------------------------
int T[4][4][4] =
{
	{
		{ 0, 1, 0, 0 },
		{ 1, 1, 1, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 1, 0, 0 },
		{ 1, 1, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 0, 0, 0 },
		{ 1, 1, 1, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 0, 0, 0 }
	},
	{
		{ 0, 1, 0, 0 },
		{ 0, 1, 1, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 0, 0, 0 }
	}
};


// Convenience function to copy 3D arrays
void Copy3DArray(int src[4][4][4], int dest[4][4][4])
{
	for (int k = 0; k < 4; k++)
	{
		for (int j = 0; j < 4; j++)
		{
			for (int i = 0; i < 4; i++)
			{
				src[k][j][i] = dest[k][j][i];
			}
		}
	}
}

//-----------------------------------------------------------------------------
// Piece class
//-----------------------------------------------------------------------------
Piece::Piece(PIECETYPE type)
{
	switch (type)
	{
	case PIECE_I:
		Copy3DArray(m_blocks, I);
		break;
	case PIECE_S:
		Copy3DArray(m_blocks, S);
		break;
	case PIECE_Z:
		Copy3DArray(m_blocks, Z);
		break;
	case PIECE_J:
		Copy3DArray(m_blocks, J);
		break;
	case PIECE_L:
		Copy3DArray(m_blocks, L);
		break;
	case PIECE_O:
		Copy3DArray(m_blocks, O);
		break;
	case PIECE_T:
		Copy3DArray(m_blocks, T);
		break;
	}

	X = 3;
	Y = 0;
	m_direction = 0;
}


Piece::~Piece()
{
}

bool Piece::OutOfBounds()
{
	for (int j = 0; j < 4; j++)
	{
		for (int i = 0; i < 4; i++)
		{
			if (GetBlock(i, j))
			{
				int x = X + i;
				int y = Y + j;
				if (x < 0 || x >= BOARD_W || y < 0 || y >= BOARD_H)
					return true;
			}
		}
	}
	return false;
}

// Push the piece back away out from the wall/floor
void Piece::Kick()
{
	bool foundCol;
	do
	{
		foundCol = false;
		for (int j = 0; j < 4; j++)
		{
			for (int i = 0; i < 4; i++)
			{
				if (GetBlock(i, j))
				{
					int x = X + i;
					int y = Y + j;
					if (x < 0)
					{
						this->X++;
						foundCol = true;
					}
					else if (x >= BOARD_W)
					{
						this->X--;
						foundCol = true;
					}

					if (y >= BOARD_H)
					{
						this->Y--;
						foundCol = true;
					}
				}
			}
		}
	} while (foundCol);
}

void Piece::Render(int x, int y)
{
	for (int j = 0; j < 4; j++)
	{
		for (int i = 0; i < 4; i++)
		{
			int blockx = x + (i+X)*BLOCK_SIZE;
			int blocky = y + (j+Y)*BLOCK_SIZE;
			if (GetBlock(i, j))
			{
				al_draw_filled_rectangle(blockx, blocky, blockx + BLOCK_SIZE, blocky + BLOCK_SIZE, al_map_rgb(255, 0, 0));
				al_draw_rectangle(blockx, blocky, blockx + BLOCK_SIZE, blocky + BLOCK_SIZE, al_map_rgb(255, 255, 255), 1);
			}
		}
	}
}
